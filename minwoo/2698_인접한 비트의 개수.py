# 인접한 비트의 개수 = 인접한 수 두 가지를 곱한 총 합
# 오..
# S : 이진으로 구성된 수열 1010010101...
# 인접한 비트의 개수는 2^31 -1 보다 작음
# n : 수열 S의 크기

# 3차원 dp...?
# 어렵게 생각말고 끝에 1이 오느냐, 0이 오느냐가 추가된 점화식이라 생각
# 결국 n과 k 두 변수에 대한 점화식인데 0, 1 한차원이 끝에 더 붙어있음

# 테스트 케이스의 수를 입력받습니다.
t = int(input())

# dp[i][j][k]는 길이가 i이고 인접한 비트의 수가 j이며 마지막 비트가 k인 이진 수열의 개수를 저장합니다.
# 이를 위해 3차원 리스트를 초기화합니다.
dp = [[[0]*2 for _ in range(100)] for _ in range(101)]

# 길이가 1인 이진 수열의 경우를 초기화합니다.
# 길이가 1이고 인접한 비트의 수가 0이며 마지막 비트가 0 또는 1인 이진 수열은 각각 하나씩 있습니다.
dp[1][0][1] = 1
dp[1][0][0] = 1

# 모든 가능한 길이와 인접한 비트의 수에 대해 dp 값을 계산합니다.
for k in range(100):
    for n in range(2, 101):
        # 마지막 비트가 1인 경우, 이전 비트가 0이어야 하므로 인접한 비트의 수는 변하지 않습니다.
        # 따라서 dp[n][k][1] = dp[n-1][k][0]입니다.
        # 마지막 비트가 0인 경우, 이전 비트가 0이든 1이든 상관없으므로 인접한 비트의 수는 변하지 않습니다.
        # 따라서 dp[n][k][0] = dp[n-1][k][0] + dp[n-1][k][1]입니다.
        if k == 0:
            dp[n][k][1] = dp[n-1][k][0]
        else:
            dp[n][k][1] = dp[n-1][k][0] + dp[n-1][k-1][1]
        dp[n][k][0] = dp[n-1][k][0] + dp[n-1][k][1]

# 각 테스트 케이스에 대해 결과를 출력합니다.
for _ in range(t):
    n, k = map(int, input().split())
    print(dp[n][k][0] + dp[n][k][1])