# 숫자의 길이를 늘려본다는 아이디어.. <- 근거가 무엇..?

# 두번째 테스트케이스에 힌트가 있다.
# [3, 30, 34, 5, 9] -> 9 5 34 3 30
# -> 3이 30보다 앞에온다 그리고 34보다는 뒤에있다
# 직관적으로 생각해보면 아리송한게 9, 5의 위치는 이해가 가지만 34 3 30 이 이상함.
# 결국 한자릿수가 들어가는 위치를 처리해야
# 그래서 숫자의 길이를 늘려준다.
# 그리고 원소의 길이가 1000이하이기 때문에 lambda x: x * 3으로 문자열 곱셈을 할 수 있다.
# 343434  333 303030 -> 자릿수를 비교하면
# 343 > 333 > 303

# []

def solution3(numbers):
    str_numbers = sorted(list(map(str, numbers)), reverse=True, key = lambda x:x*3)
    return str(int(" ".join(str_numbers)))

# ++++ test case 11


# '0000' -> 0으로 바꿔줘야 한다.
# '0000' -> int('0000') -> 0 다시 문자열로
# 그런데 이건.. '0000', '000', '00', '0'모두 복수정답으로 인정해줘야 하는 것 아닌가?
# 문제의 목적은 가장 큰 수를 구하는 것인데.. 억까다 이건



# + 번외..
# 마지막에 int로 바꾸고 다시 str로 변환하는 과정에서 시간이 오래 걸림.
# 만일 저 코드에서 더 줄이고 싶으시면 리스트의 모든 요소가 0인 경우를 체크하는 로직을 만들고,
# 그것만 처리해주시면 짧은 시간으로도 통과가능

