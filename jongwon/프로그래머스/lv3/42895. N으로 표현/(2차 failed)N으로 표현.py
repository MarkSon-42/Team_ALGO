# 1차 시도에서 55는 5를 이어 붙인 수 이고, d[1]에서 만든 수로 사칙연산을 한 숫자들로 d[2]가 만들어진다.라는 점을 알게 되서 d[3]에도 똑같이 적용하면,
# 1차 시도 : d[1] 사칙연산 d[1] = d2 + 5를 2번 이어 붙인 수 = d[2]
# d[3] = 5를 3번 이어 붙인수 + d[1] 사칙연산 d[2] + d[2] 사칙연산 d[1] 이것을 유도할 수 있었다. -> +,*는 숫자의 자리가 바뀌어도 값이 같지만 -, /는 자리가 바뀌게 되면 수가 달라진다.
# 그럼 5을 3번 사용했을 경우에는 더해서 3이 나올 수 있는 경우인 1+2, 2+1 이렇게 두가지 경우의 수가 생긴다.
# 똑같이 d[4]는 5를 4번 사용했을 경우이므로 4가 나올수 있는 경우의 수인 1+3, 2+2, 3+1 이렇게 3가지 경우의 수가 생기므로,
# d[4] = 5를 4번 이어 붙인수 + d[1] 사칙연산 d[3] + d[2] 사칙연산 d[2] + d[3] 사칙연산 d[1]으로 표현 할수 있다.
# 일반화 시키면, N을 k번 사용해서 만드는 수의 경우의 수는 N을 k번 이어 붙인수 + N을 1번 사용했을 때 사칙연산 N을 k-1번 사용했을 때 + N을 2번 사용했을 때 사칙연산 N을 k-2번 사용했을 때 
# + ... + N을 k-1번 사용 했을 때 사칙연산 k를 1번 사용했을 때라는 일반화 식이 도출된다.
# 각 횟수 마다 만들어진 수들을 검사해서 numbers가 들어있는 곳의 5를 사용한 횟수를 반환 하면 될 것 같다.

def solution(N, number):
    d = [[] for _ in range(8)] # 8번 이후로는 -1로 반환하므로 값을 받을 8개의 메모리 생성
    minimum = -1
    
    # 미리 5를 k번 이어붙인 경우의 수를 넣어놓는다.
    for i in range(8):
        d[i].append(int(str(N)*(i+1))) # [[5], [55], [555], [5555], [55555], [555555], [5555555], [55555555]]
    
    # N을 k번 사용해서 만드는 수의 경우의 수는 N을 k번 이어 붙인수 + N을 1번 사용했을 때 사칙연산 N을 k-1번 사용했을 때 + N을 2번 사용했을 때 사칙연산 N을 k-2번 사용했을     때 + ... + N을 k-1번 사용 했을 때 사칙연산 k를 1번 사용했을 때
    for i in range(1,9):
        for j in range(i):
            d[i-1].append(N+N)
            d[i-1].append(N-N)
            d[i-1].append(int(N/N))
            d[i-1].append(N*N)
    #[[5, 10, 0, 1, 25], [55, 10, 0, 1, 25, 10, 0, 1, 25], [555, 10, 0, 1, 25, 10, 0, 1, 25, 10, 0, 1, 25], [5555, 10, 0, 1, 25, 10, 0, 1, 25, 10, 0, 1, 25, 10, 0, 1, 25], [55555, 10, 0, 1, 25, 10, 0, 1, 25, 10, 0, 1, 25, 10, 0, 1, 25, 10, 0, 1, 25], [555555, 10, 0, 1, 25, 10, 0, 1, 25, 10, 0, 1, 25, 10, 0, 1, 25, 10, 0, 1, 25, 10, 0, 1, 25], [5555555, 10, 0, 1, 25, 10, 0, 1, 25, 10, 0, 1, 25, 10, 0, 1, 25, 10, 0, 1, 25, 10, 0, 1, 25, 10, 0, 1, 25], [55555555, 10, 0, 1, 25, 10, 0, 1, 25, 10, 0, 1, 25, 10, 0, 1, 25, 10, 0, 1, 25, 10, 0, 1, 25, 10, 0, 1, 25, 10, 0, 1, 25]]
    
    for i in range(8):
        if number in d[i]:
            minimum = min(minimum,i)
        else:
            minimum = -1
    return minimum

# 만들어진 숫자들의 리스트 속에서 number를 찾는 가장 작은 N 사용 횟수를 반환하려는 생각이었는데 코드로 옮기려고 보니 실패...




