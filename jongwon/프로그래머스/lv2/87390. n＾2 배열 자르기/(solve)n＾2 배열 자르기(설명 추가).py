# 1차 실패에서 시간 복잡도를 줄이기 위해 2차원 배열을 생성하여 구현하지 말고 left, right 범위 내에서의 1차원 배열만을 생성하여 필요한 부분에서 칸 안의 값만 반환하여 구현
# 1차 실패에서 i,j의 값중 큰 값이 그 칸의 값이 된다는 것을 알게 되었고 일차원 배열에서도 범위내의 칸의 행과 열의 값을 구하고 그 값들중 큰 값을 칸의 값으로 결정하여 일차원 배열을 구성하여 결과 반환

# 2차원 배열을 생성하지 않고 원하는 범위에 직접 접근하여 계산하므로 시간 복잡도 : O(n^2 + right - left)

def solution(n, left, right):
    result = []
    
    for i in range(left, right + 1): # 1차원 배열에서의 인덱스를 2차원 배열의 행과 열로 변환
        row = i // n # 행 번호 : i를 배열의 크기 n으로 나눈 몫 (i가 몇 번째 행에 위치)
        col = i % n # 열 번호 :  i를 배열의 크기 n으로 나눈 나머지 (i가 해당 행에서 몇 번째 열에 위치)
         
        max_val = max(row, col)
        value = max_val + 1 # 인덱스로 구하기 때문에 값에 1 더해주기
        
        result.append(value)
    
    return result



# 주어진 범위인 left부터 right까지 반복합니다.
# 현재 인덱스 i를 이용하여 해당 인덱스가 위치한 행과 열을 계산합니다.
# 행과 열 중 더 큰 값을 구하고, 그 값에 1을 더하여 숫자 value를 계산합니다.
# value를 결과 리스트 result에 추가합니다.
# 반복이 끝나면 result를 반환합니다.
# 이 구현은 기존 코드와 달리 2차원 배열을 생성하지 않고 원하는 범위에 직접 접근하여 계산하므로 시간 복잡도가 O(n^2 + right - left)로 줄어듭니다.

# row와 col을 저렇게 구현한 이유는 1차원 배열에서 인덱스를 2차원 배열의 행과 열로 변환하기 위해서입니다.

# 기존의 2차원 배열에서 left부터 right까지의 범위를 구하는 것과 같은 기능을 1차원 배열에서 구현해야 합니다. 이를 위해 1차원 배열의 인덱스를 2차원 배열의 행과 열로 변환해야 합니다.

# 1차원 배열에서의 인덱스 i를 행과 열로 변환하기 위해 다음과 같은 과정을 거칩니다:

# 행 번호 row를 구하기 위해서는 i를 배열의 크기 n으로 나눈 몫을 사용합니다. 이렇게 함으로써 i를 n으로 나눈 몫은 i가 몇 번째 행에 위치하는지를 나타냅니다.

# 열 번호 col를 구하기 위해서는 i를 배열의 크기 n으로 나눈 나머지를 사용합니다. 이렇게 함으로써 i를 n으로 나눈 나머지는 i가 해당 행에서 몇 번째 열에 위치하는지를 나타냅니다.

# 예를 들어, n이 4일 때 i가 7이라면:

# 행 번호 row는 7을 4로 나눈 몫인 1입니다. 따라서 row는 1입니다.
# 열 번호 col는 7을 4로 나눈 나머지인 3입니다. 따라서 col는 3입니다.
# 이렇게 row와 col을 구하면 1차원 배열에서의 인덱스 i를 2차원 배열의 행과 열로 변환할 수 있습니다. 이를 활용하여 해당 인덱스가 위치한 행과 열을 계산하고, 그에 따라 숫자 값을 결정할 수 있습니다.