def solution(x, y, n):
    # x와 y가 이미 같은 경우, 연산이 필요하지 않으므로 0을 반환
    if x == y:
        return 0

    # dp 배열 초기화, dp[i]는 i를 만들기 위한 최소 연산 횟수를 저장
    # 여기서는 초기값을 10^9로 설정
    # 초기값은 충분히 큰 값을 사용하여 x를 y로 변환하기 위해 필요한 연산 횟수의 최댓값보다 크거나 float['int']
    dp = [10**9] * (y + 1)
    dp[x] = 0  # 초기 값 설정: x를 만들기 위한 연산 횟수는 0

    # x부터 y까지 반복하면서 dp 배열 업데이트
    for i in range(x, y + 1):
        # dp[i]가 초기값(10^9)이면 아무 작업을 수행하지 않음
        if dp[i] == 10**9:
            continue

        # i에 n을 더한 값이 y 이하이면서 해당 연산 횟수가 현재 저장된 값보다 작을 경우 업데이트
        if i + n <= y:
            dp[i + n] = min(dp[i + n], dp[i] + 1)

        # i를 2배한 값이 y 이하이면서 해당 연산 횟수가 현재 저장된 값보다 작을 경우 업데이트
        if i * 2 <= y:
            dp[i * 2] = min(dp[i * 2], dp[i] + 1)

        # i를 3배한 값이 y 이하이면서 해당 연산 횟수가 현재 저장된 값보다 작을 경우 업데이트
        if i * 3 <= y:
            dp[i * 3] = min(dp[i * 3], dp[i] + 1)

    # dp 배열의 마지막 값이 초기값(10^9)인 경우, y를 만들 수 없다는 의미이므로 -1을 반환
    if dp[y] == 10**9:
        return -1

    # dp 배열의 마지막 값이 초기값이 아니라면, y를 만들기 위한 최소 연산 횟수를 반환
    return dp[y]

# 초기화: 먼저, 연산을 수행한 결과가 저장될 배열 dp를 초기화합니다. dp[i]는 자연수 i를 만들기 위한 최소 연산 횟수를 저장하는 배열입니다. 초기에는 모든 값을 큰 값으로 설정하여 나중에 갱신할 수 있도록 합니다. 예제에서는 10^9를 사용하였습니다.

# 기본 설정: 만약 x가 y와 이미 같은 경우, 연산이 필요 없으므로 0을 반환합니다.

# dp 초기값 설정: 배열 dp에서 x에 해당하는 위치의 값을 0으로 설정합니다. 이는 x를 만들기 위한 최소 연산 횟수가 이미 0이라는 의미입니다.

# 동적 프로그래밍 수행: 반복문을 통해 x부터 y까지의 범위를 순회하면서 배열 dp를 업데이트합니다. 현재 위치 i에 대해 가능한 연산을 수행하고, 해당 연산을 통해 도달할 수 있는 값들에 대해 최소 연산 횟수를 갱신합니다.

# i + n: 현재 값에 n을 더한 경우
# i * 2: 현재 값에 2를 곱한 경우
# i * 3: 현재 값에 3을 곱한 경우
# 이때, 각 경우에서 계산된 연산 횟수가 현재 저장된 값보다 작을 경우에만 갱신을 수행합니다.

# 결과 확인: 마지막으로 배열 dp에서 y에 해당하는 위치의 값이 초기값이 아닌 경우, y를 만들기 위한 최소 연산 횟수를 반환합니다. 초기값인 경우에는 y를 만들 수 없다는 의미로 -1을 반환합니다.