# 문제를 풀 때 n이 1이상 10억 이하인 것을 보고 0에서 쌓아가며 n까지 가는 것 보다 n에서 0으로 줄이면서 오는 방법이 문제 해결에 더 쉬울 것이라고 생각하여
# n이 홀수 일때는 1칸 점프를 하고 간 거리 만큼 배터리 사용량 증가, n이 짝수 일때는 순간이동하는 방식 선택
# 0에서 출발 할때 순간이동은 온 거리 * 2이니까 거꾸로 오면 도착까지 남은 거리 / 2가 되므로 n이 짝수 일때는 2로 나눠주고 홀수일때는 1칸 점프를 하여 1을 빼주고, 
# 배터리 사용량에 +1을 하는 로직으로 구현


def solution(n):
    battery = 0 # 사용 배터리 양
    
    while True:
        if n == 0: 
            break
        if n % 2 == 0: # 순간이동 (짝수)
            n /= 2
        else: # 홀수 일때 1칸 점프
            n -= 1 
            battery += 1
    
    return battery
            
    
    
    
    