def solution(number, k):
    answer = [] # Stack
    
    for num in number:
        while k > 0 and answer and answer[-1] < num:
            answer.pop()
            k -= 1
        answer.append(num)
        
    return ''.join(answer[:len(answer) - k])

# 핵심은 스택의 마지막 값이 push 할 값보다 작다면 크거나 같은 값이 나올 때까지 값들에 대해서 pop을 하는 것입니다.
# 이렇게 풀이하면 O(n)의 시간 복잡도로 문제를 해결할 수 있습니다.
# 3.4.1 알고리즘
# 스택 생성 => 파이썬에서는 리스트 활용 가능
# number를 순회 => for num in number:
# 다음 조건문을 모두 만족할 경우 명령문을 반복
# 조건문
# 1. k > 0
# 2. 스택이 비어있지 않음
# 3. 스택 마지막 값 < num
# 명령문
# 1. 스택을 pop
# k--
# 스택에 num을 push
# k > 0 이상이면 스택에서 k개 삭제 후 join해서 결과 값 반환
# 3.4.2 풀이 예시
# 앞자리에 큰 숫자가 오는 것이 전체 수를 크게 만들 수 있습니다.

# number = "4177252841", k=4일 경우,

# (k=4) []
# (k=4) [4]
# (k=4) [4, 1]
# (k=3) [4]
# (k=2) []
# (k=2) [7]
# (k=2) [7, 7]
# (k=2) [7, 7, 2]
# (k=1) [7, 7]
# (k=1) [7, 7, 5]
# (k=1) [7, 7, 5, 2]
# (k=0) [7, 7, 5]
# (k=0) [7, 7, 5, 8]
# (k=0) [7, 7, 5, 8, 4]
# (k=0) [7, 7, 5, 8, 4, 1]
# retrun "775841"
# number = "999", k=2일 경우,

# (k=2) []
# (k=2) [9]
# (k=2) [9, 9]
# (k=2) [9, 9, 9]
# return "9"